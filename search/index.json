[{"content":" 发现问题 在开发公司一个 H5 后台接口的时候，前端突然和我说接口抛了异常，但当我知道是哪个接口后，却陷入了疑惑，因为报错的是历史接口，都没动过。\n 通过看日志才发现是 token 没有传，请求头里没有，浏览器 application Cookie 里也看不到，找到设置 Cookie 的地方，发现 Set-Cookie 响应头后面有个感叹号，不管是控制台还是点击感叹号、鼠标悬浮感叹号上，都没有任何提示信息。\n 所有 Set-Cookie 后面都有感叹号，所以图片截的是 jsessionid 的\n   经过查找资料发现，从 Chrome 51 起加个 SameSite 的属性，用于防御 跨站请求伪造（CSRF），这个值默认是 None，也就是允许所有第三方 Cookie，然而从 Chrome 80 开始，SameSite 的默认值变成了 Lax。\n 微信授权需要 https，而本地没有 https 的条件（域名证书公司领导管理），虽然一级域名一样，但是还是无法保存 Cookie。\n   解决问题 我们的页面是嵌入微信小程序的，不存在开放 H5 直接访问的可能，所以这里我可以将 SameSite 的值手动设置为 None。\n 方案1 不使用 HttpServletResponse.addCookie 但当我动手时，又发现 Servlet API 4.0.1 中 Cookie 对象并不支持 SameSite 属性，于是我决定不使用 HttpServletResponse.addCookie，手动拼接响应报文头。\n /** * Web 工具类，判断是不是 https * @author c332030 */ public class WebUtils { public static final String HTTPS = \u0026#34;https\u0026#34;; private WebUtils() {} public static boolean isHttps(HttpServletRequest request) { // 考虑到 nginx 代理的情况，读取：X-Forwarded-Proto String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO); if(StringUtils.isEmpty(scheme)) { scheme = request.getScheme(); } return HTTPS.equalsIgnoreCase(scheme); } }   /** * Cookie 工具类 * @author c332030 */ public class CookieUtils { private CookieUtils() {} public static final String HTTPS = \u0026#34;https\u0026#34;; public static final String Cookie_Domain = \u0026#34;; Domain=\u0026#34;; public static final String Cookie_Path = \u0026#34;; Path=\u0026#34;; public static final String Cookie_MaxAge = \u0026#34;; Max-Age=\u0026#34;; public static final String Cookie_Secure = \u0026#34;; Secure\u0026#34;; public static final String Cookie_HttpOnly = \u0026#34;; HttpOnly\u0026#34;; public static final String Cookie_SameSite = \u0026#34;; SameSite=\u0026#34;; public static final String Cookie_SameSite_None = \u0026#34;None\u0026#34;; public static final String Cookie_SameSite_Lax = \u0026#34;Lax\u0026#34;; public static final String Cookie_SameSite_Strict = \u0026#34;Strict\u0026#34;; /** * 添加 Cookie，替代 HttpServletResponse.addCookie() */ public static void addCookie(HttpServletRequest request, HttpServletResponse response, Cookie cookie) { StringBuilder cookHeaderStr = new StringBuilder(); cookHeaderStr.append(cookie.getName()); cookHeaderStr.append(\u0026#34;=\u0026#34;); cookHeaderStr.append(cookie.getValue()); StringOptional.ofEmptyAble(cookie.getDomain()).ifNotEmpty(e -\u0026gt; { cookHeaderStr.append(Cookie_Domain); cookHeaderStr.append(e); }); cookHeaderStr.append(Cookie_Path); String path = StringUtils.isNotEmpty(cookie.getPath()) ? cookie.getPath() : \u0026#34;/\u0026#34;; cookHeaderStr.append(path); if(cookie.getMaxAge() \u0026gt;= 0) { cookHeaderStr.append(Cookie_MaxAge); cookHeaderStr.append(cookie.getMaxAge()); } // SameSite=None 且 https 时，需要设置 Secure 属性 if(WebUtils.isHttps(request) || cookie.getSecure()) { cookHeaderStr.append(Cookie_Secure); } if(cookie.isHttpOnly()) { cookHeaderStr.append(Cookie_HttpOnly); } cookHeaderStr.append(Cookie_SameSite); cookHeaderStr.append(Cookie_SameSite_None); response.addHeader(HttpHeaders.SET_COOKIE, cookHeaderStr.toString()); } }   如果在 https 的网络下设置 SameSite=None 但没有设置 Secure 属性时，也会出现感叹号，不过这个时候是有提示的。\n     这个时候 token 的 Cookie 是管用了，可是 jsessionid 的 Cookie 没有加上 SameSite 属性，我只能换一种方案。\n  方案2 使用过滤器 于是我想到了过滤器，直接上代码。\n /** * 常量类不解释 * @author c332030 */ public class HttpHeaderConstants { private HttpHeaderConstants() {} public static final String HTTPS = \u0026#34;https\u0026#34;; public static final String Cookie_SameSite = \u0026#34;SameSite\u0026#34;; public static final String Cookie_SameSite_Strict = \u0026#34;Strict\u0026#34;; public static final String Cookie_SameSite_Lax = \u0026#34;Lax\u0026#34;; public static final String Cookie_SameSite_None = \u0026#34;None\u0026#34;; public static final String Cookie_Secure = \u0026#34;Secure\u0026#34;; }   /** * Cookie 工具类 * @author c332030 */ public class CookieUtils { private CookieUtils() {} public static String getAppendedHeader(String header, String key) { return getAppendedHeader(header, key, null); } public static String getAppendedHeader(String header, String key, String value) { StringBuilder stringBuilder = new StringBuilder(header); append(stringBuilder, key, value); return stringBuilder.toString(); } public static void append(StringBuilder headerBuilder, String key) { append(headerBuilder, key, null); } public static void append(StringBuilder headerBuilder, String key, String value) { headerBuilder.append(\u0026#34;; \u0026#34;); headerBuilder.append(key); if (StringUtils.isNotEmpty(value)) { headerBuilder.append(\u0026#34;=\u0026#34;); headerBuilder.append(value); } } /** * 获取 HttpServletResponse 中已有的 Cookie，然后拼接上 SameSite 属性 * @author c332030 */ public static void appendSameSite(HttpServletRequest request, HttpServletResponse response, String defaultSameSiteValue) { Collection\u0026lt;String\u0026gt; cookieHeaders = response.getHeaders(HttpHeaders.SET_COOKIE); if(CollectionUtils.isEmpty(cookieHeaders)) { return; } List\u0026lt;String\u0026gt; cookieHeadersNew = new ArrayList\u0026lt;\u0026gt;(cookieHeaders.size()); cookieHeaders.forEach(cookieHeader -\u0026gt; { if (cookieHeader.contains(HttpHeaderConstants.Cookie_SameSite)) { cookieHeadersNew.add(cookieHeader); return; } StringBuilder stringBuilder = new StringBuilder(cookieHeader); // SameSite=None CookieUtils.append(stringBuilder, HttpHeaderConstants.Cookie_SameSite, defaultSameSiteValue); // Secure if (WebUtils.isHttps(request) \u0026amp;\u0026amp; !cookieHeader.contains(HttpHeaderConstants.Cookie_Secure)) { CookieUtils.append(stringBuilder, HttpHeaderConstants.Cookie_Secure); } cookieHeadersNew.add(stringBuilder.toString()); }); Iterator\u0026lt;String\u0026gt; cookieHeadersIterator = cookieHeadersNew.iterator(); // clear old cookies response.setHeader(HttpHeaders.SET_COOKIE, cookieHeadersIterator.next()); while (cookieHeadersIterator.hasNext()) { response.addHeader(HttpHeaders.SET_COOKIE, cookieHeadersIterator.next()); } } }   /** * SameSite 过滤器 * @author c332030 */ public class SameSiteFilter implements Filter { @Override public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { chain.doFilter(request, response); // 执行完业务流程再修改 Cookie CookieUtils.appendSameSite(request, response, HttpHeaderConstants.Cookie_SameSite_None); } }   在单元测试中，CookieUtils.appendSameSite 方法正常运行，字符串拼接的值也是对的，可是返回的报文中却没有 SameSite 和 Secure 属性。\n 查找 Stackoverflow 资料得知，response.setHeader 需要修改响应，但响应请求已经提交时，服务器就会忽略对 response 做出的修改。\n 过滤器中出现这种情况只发生在添加了 @ResponseBody 注解的接口上。\n 这个问题刚发现的时候，着实让我无法理解，后来我想到 response.getWriter 关闭后再写入数据时会报错，我也就理解了。\n 这个时候就只能在提交前做修改了。\n  方案3 实现 ResponseBodyAdvice 在提交前做修改 还好有先见之明，考虑到拼接 SameSite 的需求可能会在其他地方用到，所以抽离出了 CookieUtils.appendSameSite 方法。\n /** * 实现 ResponseBodyAdvice，在提交前修改 Cookie * @author c332030 */ @ControllerAdvice public class SameSiteControllerAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { HttpServletRequest request = ((ServletServerHttpRequest) serverHttpRequest).getServletRequest(); HttpServletResponse response = ((ServletServerHttpResponse) serverHttpResponse).getServletResponse(); CookieUtils.appendSameSite(request, response, HttpHeaderConstants.Cookie_SameSite_None); return body; } }   以前只知道有 @ControllerAdvice 这个注解，但是不知道具体干嘛用的，这次终于用上了。\n 这次终于成功了，升级最新版微信开发工具测试后，Cookie 传递正常，来张成功的截图。\n    方案4，使用 Spring Boot 自带的功能 这个方案我很早就搜到了，但是要求 Spring Boot 2.6.0+，我们现在还在使用 Spring Boot 2.4.4，所以我都没有去尝试，在此我也记录下，毕竟使用 Spring Boot 本身的功能是最简单的。\n 见文档： https://docs.spring.io/spring-boot/docs/2.6.0/reference/html//web.html#web.servlet.embedded-container.customizing.samesite\n 方式1\n server.servlet.session.cookie.same-site=none   方式2\n @Configuration(proxyBeanMethods = false) public class MySameSiteConfiguration { @Bean public CookieSameSiteSupplier applicationCookieSameSiteSupplier() { return CookieSameSiteSupplier.ofLax().whenHasNameMatching(\u0026#34;myapp.*\u0026#34;); } }      ","date":"2022-05-20T22:00:00Z","permalink":"https://c332030.com/p/2022/05/%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%90%8E%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98cookie/","title":"解决升级微信开发者工具后无法保存Cookie"},{"content":"前言 公司项目的版本号要么是快照版本（以-SNAPSHOT），要么是发行版本却一直在一个分支上开发，这就会有几个问题：\n  maven 默认不下载快照版本的依赖，导致私服上有依赖也下载不下来；\n  使用发行版本时，却从来不变更版本号，导致依赖有更新却不会去私服上下载；\n  一直在单个分支上开发就会导致代码有变更时，旧项目无法再取到未变更的依赖， 我们也没法保留之前上线过的版本的源代码，导致旧版本有需求时，不得不加在在最新的代码上， 部署也是部署最新的代码，很多不是此次上线的功能也部署上去了。\n   除却版本定义和单分值的问题外，还有以下问题：\n  项目中的版本号都是手动管理，在 dependencies 中添加模块依赖时，要么采用占位符 ${} 的方式， 要么直接把版本号写在这里，这就导致后面版本号的更新操作变得困难或无法自动化处理。\n     方案 针对公司项目管理的这些问题，在征得领导的同意后，采取以下措施进行解决：\n  对项目的分支进行标准化管理，重点是功能变更测试完成后需要打 tag（具体见后文）；\n  对开发分支使用快照版本，为其他开发成员开启下载快照版本的功能；\n  对项目中所有当前项目的模块依赖直接指定版本号（便于使用自动化工具），并且对其他项目会用到的模块在根目录的 pom.xml 中使用 dependencyManagement 管理，这样子模块中的模块依赖就不需要指定版本号；\n  打 tag 之前，保证项目中依赖的其他项目的模块版本号都是发行类型（不以 -SNAPSHOT 结尾），保证依赖的代码不会变更；\n  打完 tag 的项目是发行版本，不再接受代码变更，并且上传依赖到私服；\n  新建一个 pom 类型的项目，名称以 -bom 结尾（参考 spring，不使用 dependencies 的原因是 bom 更方便输入）；\n  把 dependencyManagement 中的模块依赖复制过来。\n     具体操作 示例项目介绍 首先介绍下为了写这个建的两个示例项目\n c-commons 这个项目取名：c-commons，名字参考了 apache 的 commons 项目，顾名思义，存放公共代码的地方\n    c-mall 这个是一个商城的项目，这个项目要依赖 c-commons 中的模块：\n       1. 调整依赖 首先，所有引用到了模块中子模块的地方都直接指明版本号，这里还分两种情况\n  会被多个模块或者其他项目引用的模块；\n  只会被某一个模块引用的模块。\n   先说第二种情况，这种情况下，直接在引用的地方加上版本号。\n 如果是第一种情况，我们在根目录的 pom.xml 中添加 dependencyManagement 标签，把这些会被多次引用的模块添加到其中，如图：\n     而在当前项目其他模块中使用时，可以不指定版本号，此时 idea 左侧出现蓝色跳转符号：\n   当鼠标悬浮在符号上时，可以看到此处虽然没有指定版本号，但是却能够找到确切的版本，这个版本号是在 dependencyManagement 中定义的、\n   我这里还建了一个名为 c-commons-bom 的项目，目的是方便其他项目依赖 c-commons 和统一依赖版本。\n 可以看到这个项目只有一个 pom.xml 文件：\n   细心的人会发现，我在 c-commons 的 pom.xml 文件中加了星号的注释，这样的注释是成对的，包裹着其他项目会依赖的模块。我把这些模块复制到 c-commons-bom 中。\n     对 c-commons 和 c-commons-bom 项目分别执行 mvn clean install 命令，把项目存到本地仓库中。\n 在 c-mall 中以 type=pom 和 scope=import 的方式引用：\n   在 c-mall 中引用 c-commons 中的模块时，可以发现，也不需指定版本号了。\n   点进去，版本号是在本地仓库 c-commons-bom 项目中指定的：\n   dependencyManagement 中还可以加入其他依赖并添加到 c-commons-bom 中，比如 fastjson，这样引入 c-commons 项目模块时，可以统一所有项目的 fastjson 版本。\n  2. 更新版本号 这里用到 maven 插件 Versions Maven Plugin，可以管理项目的版本号\n https://www.mojohaus.org/versions-maven-plugin/\n 用到的命令如下：\n 更新版本号：mvn versions:set\n 回滚版本号：mvn versions:revert\n 执行命令时，会提示输入新的版本号：\n   执行完会生成 .versionsBackup 的备份文件，用于回滚版本号\n   回滚：\n   因为其他同事之前手动上传过 jar 到私服，指定了版本号，为了不冲突，需要指定一个新的版本号，命令如下：\n mvn versions:set ^ -DnewVersion=1.0.1-SNAPSHOT    3. 生成 tags 这里用到 Maven Release Plugin 插件\n https://maven.apache.org/maven-release/maven-release-plugin/\n 用到的命令如下：\n 版本号更新：mvn release:prepare\n 版本号回滚：mvn release:rollback\n 需要注意的是，这里需要在项目根 pom.xml 中添加 scm 标签，其中 developerConnection 是当前分支路径，connection 是项目的 svn 根路径。\n \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- 忽略其他 --\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;developerConnection\u0026gt;scm:svn:https://localhost:8443/svn/c/project/c-commons/branches/c-commons\u0026lt;/developerConnection\u0026gt; \u0026lt;connection\u0026gt;scm:svn:https://localhost:8443/svn/c/project/c-commons\u0026lt;/connection\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;!-- 忽略其他 --\u0026gt; \u0026lt;/project\u0026gt;   同时，项目的 svn 结构如下：\n c-commons branches c-commons c-commons-2.0.0-SNAPSHOT-jdk8 tags c-commons-1.0.0   branches 文件夹下存放分支，项目同名目录 c-commons 存放主干，其他的是并行开发的分支。这里主干不放到 trunk 的原因是：trunk 目录 checkout 下来的文件夹和项目名称不一致，为了 checkout 后不需要修改文件夹名称，主干我放到 branches 下面。\n 目前 branches 下只有 c-commons 目录，tags 目录是空的，因为我还没执行命令。\n 这里需要 checkout 项目到新路径，因为使用 release 插件时，项目中不能存在有变更或者未受版本管理的文件，我这里执行：\n mvn release:prepare ^ -DautoVersionSubmodules=true   执行后，会提示输入三次：\n  第一次提示输入当前开发版本的发布版本，默认就是删除 -SNAPSHOT 的版本号；\n  第二次提示输入 tags 目录下新分支名称，默认是 \u0026#39;项目名称-发布版本号\u0026#39;；\n  第三次提示输入新的开发版本号，默认当前版本号 x.y.z 中的 z 加一。\n   没有特殊要求，按三次回车就好了。\n   执行完可以看到 tags 下多出新分支：\n   tags 下的分支版本号是发行类型的（没有后缀 -SNAPSHOT），scm 标签下的链接也更新了。\n   branches 下主分支版本号已更新：\n       需要注意的是，如果执行过程中发送错误，同时有部分代码已经提交了 svn，可以执行 mvn release:rollback 进行回滚，我这里就出错了。可以看到，编号为 11 的提交是执行 prepare 命令，编号为 12 的提交是 rollback 命令：\n      发布 这里把 tags 下的分支 checkout 下来，执行 mvn clean deploy 就可以发布私服了，具体配置这里不作阐述，因为配置不复杂，而 nexus 私服的搭建又需要讲很多内容。\n   后记 完成整个流程还是花了我不少时间，踩了不少坑，网友如果有疑问，欢迎交流。\n   ","date":"2021-05-11T21:00:00Z","permalink":"https://c332030.com/p/2021/05/maven-svn-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","title":"maven+svn 版本管理"},{"content":"前言 新买的 真我GT 自带了一些应用，试过不是很好用，但是手机没有 root，在手机上卸载不了也停用不了，了解到可以用 adb 来停用，于是来试试。\n   准备工作 了解 adb 命令 Google 到相关的命令如下：\n 查询应用包名：adb shell pm list packages -s\n 启用应用：adb shell pm enable 包名\n 停用应用：adb shell pm disable-user 包名\n 卸载应用：adb shell pm uninstall -k --user 0 包名\n  打开 usb 调试 要执行 adb 命令，手机需要使用 usb 连接电脑，现在的手机开发者选项都是隐藏了的，可以看到设置-其他设置，SIM 应用下面是最近任务。\n 进入设置-关于手机-版本信息-版本号点7下-输入密码打开开发者模式。\n 现在设置-其他设置，SIM 应用下面是开发者选项了，点进去，打开 usb 调试。\n    安装 adb Google 搜到 adb 下载地址，下载 windows 版本 adb\n https://developer.android.com/studio/releases/platform-tools\n   解压，配置环境变量，执行 adb version，可以看到安装成功了。\n   插上 usb 线，执行 adb devices 可以看到设备已经识别了。\n   如果无法发现设备，可能需要安装 adb 驱动，可以试下这个：\n https://developer.android.com/studio/run/win-usb\n      获取所有应用包名 在命令行中执行 adb shell pm list packages -s \u0026gt; packages.txt，就把所有应用包名写入到了 packages.txt。\n     找出应用对应的包名 下载创建快捷方式应用：\n https://www.coolapk.com/apk/com.x7890.shortcutcreator\n 打开 创建快捷方式 应用，右上角勾上显示系统应用\n   搜索 浏览器，可以找到系统自带的浏览器，包名为：com.heytap.browser\n     测试命令 执行下命令测试下：adb shell pm disable-user com.heytap.browser\n   可以看到浏览器已经被停用\n     停用脚本 将以下内容保存到文本文档，重命名文档为 disable.bat 执行：\n @echo off title 停用真我GT应用 by c332030 :: 启用 :: set command=adb shell pm enable :: 停用 set command=adb shell pm disable-user :: 乐划锁屏 %command% com.heytap.pictorial :: 音乐 %command% com.heytap.music :: 小布 %command% com.heytap.speechassist :: 浏览器 %command% com.heytap.browser :: 快应用 %command% com.nearme.instant.platform :: 视频 %command% com.heytap.yoli :: 图库 %command% com.coloros.gallery3d pause \u0026gt;nul   输入如下：\n   在 bat 中，双冒号是注释，启用应用时注释/取消注释对应的命令。\n   后记 玩机过的老哥就会注意到，这里只是停用了，没有清除应用数据，我有找到清除应用的命令：adb shell pm clear 包名，但是执行时却报错了，大意是真我禁用了这个命令，其他品牌可以试试，我这是手动清的数据。\n   错误日志:  \n Exception occurred while executing \u0026#39;clear\u0026#39;: java.lang.SecurityException: adb clearing user data is forbidden. at com.android.server.pm.OplusClearDataProtectManager.interceptClearUserDataIfNeeded(OplusClearDataProtectManager.java:87) at com.android.server.pm.OplusBasePackageManagerService$OplusPackageManagerInternalImpl.interceptClearUserDataIfNeeded(OplusBasePackageManagerService.java:490) at com.android.server.am.ActivityManagerService.clearApplicationUserData(ActivityManagerService.java:4692) at com.android.server.pm.PackageManagerShellCommand.runClear(PackageManagerShellCommand.java:2148) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:237) at android.os.BasicShellCommandHandler.exec(BasicShellCommandHandler.java:98) at android.os.ShellCommand.exec(ShellCommand.java:44) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:23342) at android.os.Binder.shellCommand(Binder.java:936) at android.os.Binder.onTransact(Binder.java:820) at android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:4603) at com.android.server.pm.PackageManagerService.onTransact(PackageManagerService.java:4844) at com.android.server.pm.OplusPackageManagerService.onTransact(OplusPackageManagerService.java:150) at android.os.Binder.execTransactInternal(Binder.java:1166) at android.os.Binder.execTransact(Binder.java:1130)     \n   ","date":"2021-05-05T11:00:00Z","permalink":"https://c332030.com/p/2021/05/adb%E5%81%9C%E7%94%A8%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/","title":"adb停用自带应用"},{"content":"前言 刚进公司的时候，看到同事定义的枚举类中定义了一个 code 保存枚举的名字，大概是这样：\n public enum TestEnum { TEST(\u0026#34;TEST\u0026#34;, \u0026#34;测试\u0026#34;) ; private final String code; private final String name; TestEnum(String code, String name) { this.code = code; this.name = name; } // get set ... public static TestEnum codeOf(String code) { // 通过 code 获取枚举 } }   首先看到的是 TEST 这个单词出现了两次，然后每个枚举都定义了 codeOf，code 和 name 方法都添加了 set 方法。 我本能上觉得，java 语言不会设计得这么傻，前两个问题应该已经有了成熟方案，于是去看枚举的父类 Enum，果然找到了。\n   Enum 方法 我列出用的比较多的方法\n  name()\n获取的枚举的名称，这是一个成员方法，作用和 getCode() 是一样的     static valueOf(String name)\n这个方法作用和 codeOf 是一样的，这是一个静态方法，，name() 和这个方法都存在，那么 code 这个字段就没有用了     ordinal()\n获取枚举定义顺序，从 0 开始，这是一个成员方法，后面开发中我看到 fastjson 的序列花配置使用到了这个方法。 fastjson 的序列号配置存在一个 int 类型的字段中，二进制中的每一个位置存储了一个配置，使用 ordinal 方法来确定配置的二进制位置。     .toString()\n底层调用的 name()，所以我在传递参数给 mybatis 时，有些字段直接传的枚举，限定参数范围。     values()\n获取所有的枚举，这是一个静态方法，并没有写在 Enum 类中，是 jdk 生成的，底层是深拷贝枚举类中的枚举数组。 为什么要深拷贝一次呢，理由是避免枚举类中的枚举数组被修改，如果经常会调用这个方法，建议定义一个静态 List 常量保存起来，避免重复深拷贝。        其他 考虑到枚举类中的枚举都是常量，我用 final 修饰了 name 字段，避免 name 字段被无意修改， 后面升级 idea 后，枚举中没有 set 方法的字段都会自动加 final 修饰符，也就没有再手动修改了。\n   修改后的代码 public enum TestEnum { TEST( \u0026#34;测试\u0026#34;), ; private final String name; TestEnum(String name) { this.name = name; } /* * 兼容旧代码 */ public String getCode() { return name(); } public String getName() { return name; } }     ","date":"2021-03-21T18:48:00Z","permalink":"https://c332030.com/p/2021/03/java%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/","title":"java枚举成员方法"},{"content":"基本流程  初始化\n  业态切换（可选）\n  页面初始化（可选）\n  组件显示\n  下拉选项加载、设置\n        查询流程\n  压值\n  取值\n  值校验\n  非空校验\n  内容校验\n     数据转换、包装\n     网络通讯\n  设置通讯方式（get/post，form/json）\n  发起请求\n  结果处理（成功失败校验、错误提示）\n     数据处理\n  数据转换、格式化\n  数据展示\n        预提交\n  压值（同查询流程）\n     提交流程\n  网络通讯（同查询流程）\n     提交后处理\n  数据处理（关闭、跳转页面）\n        ","date":"2021-03-17T22:00:00Z","permalink":"https://c332030.com/p/2021/03/%E5%89%8D%E7%AB%AF%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"前端流程控制"}]